«IMPORT ecore»

«EXTENSION templates::extensions»
«EXTENSION org::eclipse::xtend::util::stdlib::io»

«DEFINE main(String p_metaModelFactory, String p_targetPackagePrefix, Boolean p_pluralizedGetters) FOR EPackage»
  «EXPAND ePackage(p_metaModelFactory, p_targetPackagePrefix, p_pluralizedGetters)»
«ENDDEFINE»

«DEFINE ePackage(String p_metaModelFactory, String p_targetPackagePrefix, Boolean p_pluralizedGetters) FOR EPackage»
  «EXPAND ePackage(p_metaModelFactory, p_targetPackagePrefix, p_pluralizedGetters) FOREACH eSubpackages»
  «EXPAND eClassifier(javaPackage(p_metaModelFactory), p_metaModelFactory, p_targetPackagePrefix, p_pluralizedGetters) FOREACH eClassifiers»
«ENDDEFINE»

«DEFINE eClassifier(String p_metaModelJavaPackage, String p_metaModelFactory, String p_targetPackagePrefix, Boolean p_pluralizedGetters) FOR EClassifier» 
«ENDDEFINE»

«DEFINE eClassifier(String p_metaModelJavaPackage, String p_metaModelFactory, String p_targetPackagePrefix, Boolean p_pluralizedGetters) FOR EClass»
  «IF isBuilderType()»  
  «FILE builderJavaFilePath(p_targetPackagePrefix)»
    package «builderJavaPath(p_targetPackagePrefix)»;            
    
    /**
     * <!-- begin-user-doc --> 
     *   A builder for the model object ' <em><b>«p_metaModelJavaPackage».«name»</b></em>'.
     * <!-- end-user-doc -->
     * 
     * @generated
     */
    public class «builderName()» {
      «EXPAND declaration(p_metaModelJavaPackage) FOREACH structuralFeatures().select(sf|!sf.isMulti())»
      
      «EXPAND declaration(p_metaModelJavaPackage) FOREACH structuralFeatures().select(sf|sf.isMulti())»
      
      «EXPAND assignmentHelperDeclaration FOREACH structuralFeatures()»
    
      /**
       * Builder is not instantiated with a constructor.
       * @see #new«builderName()»()
       */ 
      private «builderName()»() {
      }     
      
      /**
       * This method creates a new instance of the «builderName()».
       * @return new instance of the «builderName()»
       */
      public static «builderName()» new«builderName()»() {
        return new «builderName()»();
      }
      
      /**
       * This method can be used to override attributes of the builder.
       */
      public «builderName()» but() {
        «builderName()» _builder = new«builderName()»();
        
        «FOREACH structuralFeatures() AS sf»
          _builder.m_feature«sf.normalizedName().toFirstUpper()»Set = m_feature«sf.normalizedName().toFirstUpper()»Set;
          _builder.m_«sf.normalizedName()» = m_«sf.normalizedName()»;
          «IF sf.eType.isBuilderType()»
            _builder.m_feature«sf.normalizedName().toFirstUpper()»Builder = m_feature«sf.normalizedName().toFirstUpper()»Builder;
          «ENDIF»
        «ENDFOREACH»      
        return _builder;  
      }
      
      /**
       * This method constructs the final «p_metaModelJavaPackage».«name» type.
       * @return new instance of the «p_metaModelJavaPackage».«name» type
       */
      public «p_metaModelJavaPackage».«name» build() {
        final «p_metaModelJavaPackage».«name» _newInstance = «p_metaModelFactory».eINSTANCE.create«name.toFirstUpper()»();
        «EXPAND assignment(p_pluralizedGetters) FOREACH structuralFeatures()»
        return _newInstance;
      }      
      
      «EXPAND method(this, p_metaModelJavaPackage) FOREACH structuralFeatures()»
    }
  «ENDFILE»
  «ENDIF»
«ENDDEFINE»

«DEFINE declaration(String p_metaModelJavaPackage) FOR EStructuralFeature»
  «IF isMulti()»
    private java.util.Collection<«EXPAND typeDeclaration(p_metaModelJavaPackage) FOR eType»> m_«normalizedName()» = new java.util.LinkedList<«EXPAND typeDeclaration(p_metaModelJavaPackage) FOR eType»>();
  «ELSE»
    private «EXPAND typeDeclaration(p_metaModelJavaPackage) FOR eType» m_«normalizedName()»;
  «ENDIF»
  «IF eType.isBuilderType()»
	  «IF isMulti()»
	  	private java.util.Collection<«eType.builderName()»> m_feature«normalizedName().toFirstUpper()»Builder = new java.util.LinkedList<«eType.builderName()»>();
	  «ELSE»
	    private «eType.builderName()» m_feature«normalizedName().toFirstUpper()»Builder;
	  «ENDIF»
  «ENDIF»
«ENDDEFINE»

«DEFINE assignmentHelperDeclaration FOR EStructuralFeature»
  private boolean m_feature«normalizedName().toFirstUpper()»Set = false;
«ENDDEFINE»

«DEFINE typeDeclaration(String p_metaModelJavaPackage) FOR ETypedElement»
  «throwRuntimeException("Unmapped Element '" + this + "' in typeDeclaration")»
«ENDDEFINE»

«DEFINE typeDeclaration(String p_metaModelJavaPackage) FOR EClassifier»
  «throwRuntimeException("Unmapped Element '" + this + "' in typeDeclaration")»
«ENDDEFINE»

«DEFINE typeDeclaration(String p_metaModelJavaPackage) FOR EEnum»
  «p_metaModelJavaPackage».«name.toJavaRef()»
«ENDDEFINE»

«DEFINE typeDeclaration(String p_metaModelJavaPackage) FOR EDataType»
  «instanceClassName.toJavaRef()»
«ENDDEFINE»

«DEFINE typeDeclaration(String p_metaModelJavaPackage) FOR EClass»  
  «IF instanceClassName == null»
    «p_metaModelJavaPackage».«name»
  «ELSE»     
    «instanceClassName.toJavaRef()»
    «IF instanceClassName == "java.util.Map$Entry" && !structuralFeatures().isEmpty»
      <«FOREACH structuralFeatures() AS sf SEPARATOR ","»
        «EXPAND typeDeclaration(p_metaModelJavaPackage) FOR sf.eType»
      «ENDFOREACH»>
    «ENDIF»    
  «ENDIF»
«ENDDEFINE»

«DEFINE assignment(Boolean p_pluralizedGetters) FOR EStructuralFeature»
  if(m_feature«normalizedName().toFirstUpper()»Set) {
    «IF isMulti()»
      «IF p_pluralizedGetters»
        _newInstance.get«normalizedName().toFirstUpper().pluralize()»().addAll(m_«normalizedName()»);
      «ELSE»
        _newInstance.get«normalizedName().toFirstUpper()»().addAll(m_«normalizedName()»);
      «ENDIF»  
        
    «ELSE»
      _newInstance.set«normalizedName().toFirstUpper()»(m_«normalizedName()»);
    «ENDIF»  
  «IF eType.isBuilderType()»
  } else {
  	 «IF isMulti()»
  	   if (!m_feature«normalizedName().toFirstUpper()»Builder.isEmpty()) {
	     for («eType.builderName()» builder: m_feature«normalizedName().toFirstUpper()»Builder) {
	       «IF p_pluralizedGetters»
	         _newInstance.get«normalizedName().toFirstUpper().pluralize()»().add(builder.build());
	       «ELSE»
	         _newInstance.get«normalizedName().toFirstUpper()»().add(builder.build());
	       «ENDIF»  	       
  	     }
       } 
  	 «ELSE»
  	   if (m_feature«normalizedName().toFirstUpper()»Builder != null) {
  	     _newInstance.set«normalizedName().toFirstUpper()»(m_feature«normalizedName().toFirstUpper()»Builder.build());
  	   }
  	 «ENDIF»
  }
  «ELSE»
  }
  «ENDIF»
«ENDDEFINE»

«DEFINE method(EClass p_context, String p_metaModelJavaPackage) FOR EStructuralFeature»
  «IF isMulti()»
    public «p_context.builderName()» with«normalizedName().toFirstUpper()»(«EXPAND typeDeclaration(p_metaModelJavaPackage) FOR eType» p_«normalizedName()»){
      m_«normalizedName()».add(p_«normalizedName()»);
      m_feature«normalizedName().toFirstUpper()»Set = true;
      return this;
    }    
    public «p_context.builderName()» with«normalizedName().toFirstUpper()»(java.util.Collection<? extends «EXPAND typeDeclaration(p_metaModelJavaPackage) FOR eType»> p_«normalizedName()»){
      m_«normalizedName()».addAll(p_«normalizedName()»);
      m_feature«normalizedName().toFirstUpper()»Set = true;
      return this;
    }
    «IF eType.isBuilderType()»
      public «p_context.builderName()» with«normalizedName().toFirstUpper()»(«eType.builderName()» p_«eType.builderName().toFirstLower()»){
        m_feature«normalizedName().toFirstUpper()»Builder.add(p_«eType.builderName().toFirstLower()»);
        return this;
      }            
    «ENDIF»
  «ELSE»
    public «p_context.builderName()» with«normalizedName().toFirstUpper()»(«EXPAND typeDeclaration(p_metaModelJavaPackage) FOR eType» p_«normalizedName()»){
      m_«normalizedName()» = p_«normalizedName()»;
      m_feature«normalizedName().toFirstUpper()»Set = true;
      return this;
    }
    «IF eType.isBuilderType()»
      public «p_context.builderName()» with«normalizedName().toFirstUpper()»(«eType.builderName()» p_«eType.builderName().toFirstLower()»){
        m_feature«normalizedName().toFirstUpper()»Builder = p_«eType.builderName().toFirstLower()»;
        return this;
      }
    «ENDIF»
  «ENDIF»
«ENDDEFINE»
